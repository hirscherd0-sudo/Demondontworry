<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Horror Ludo Multiplayer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; background-color: #050505; color: #eee; font-family: 'Roboto', sans-serif; touch-action: none; }

        /* LAYER 0: GAME */
        #game-canvas { display: block; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }

        /* LAYER 1: HUD (FEST VERANKERT) */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-panel {
            background: rgba(20, 0, 0, 0.95); border: 3px solid #800; padding: 10px 15px; margin: 15px; 
            border-radius: 10px; pointer-events: auto; box-shadow: 0 0 20px #000; min-width: 150px;
        }

        .top-row { display: flex; justify-content: space-between; align-items: flex-start; }
        
        #identity h2, #turn-info h2 { font-family: 'Creepster', cursive; margin: 0; font-size: 1.4rem; letter-spacing: 1px; }
        #timer-box { font-size: 3.5rem; color: #f00; font-weight: bold; text-align: center; text-shadow: 0 0 15px #f00; line-height: 1; margin-top: 5px;}
        
        .bottom-row { display: flex; justify-content: center; padding-bottom: 30px; pointer-events: auto; }
        
        #status-bar {
            background: rgba(0,0,0,0.9); padding: 15px 40px; border-radius: 50px;
            font-size: 1.5rem; border: 2px solid #444; margin-bottom: 20px; text-align: center;
            color: #fff; font-weight: bold; box-shadow: 0 0 30px #000;
        }

        .btn-horror {
            background: linear-gradient(to bottom, #a00, #600); color: white; border: 3px solid #f00;
            padding: 20px 60px; font-size: 2rem; font-family: 'Creepster', cursive; cursor: pointer; 
            pointer-events: auto; box-shadow: 0 0 20px red; border-radius: 12px; transition: 0.1s;
        }
        .btn-horror:active { transform: scale(0.95); }
        .btn-horror:hover { filter: brightness(1.2); }

        /* LAYER 2: OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 5, 5, 0.98); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .hidden { display: none !important; }

        input { padding: 15px; font-size: 1.5rem; background: #222; color: white; border: 2px solid #555; margin-bottom: 25px; text-align: center; border-radius: 5px; width: 300px;}
        
        /* LOADING */
        #load-cont { width: 300px; height: 30px; background: #200; border: 2px solid #500; margin-top: 20px; border-radius: 15px; overflow: hidden; }
        #load-bar { width: 0%; height: 100%; background: #f00; transition: width 0.3s; }
        #load-txt { margin-top: 10px; color: #888; font-family: monospace; }

        /* QUIZ */
        .quiz-opt { background: #222; padding: 15px; margin: 10px; width: 90%; max-width: 400px; border: 1px solid #555; cursor: pointer; text-align: left; font-size: 1.2rem; }
        .quiz-opt:hover { border-color: red; background: #400; }

    </style>
    <!-- LIBRARIES -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- HUD -->
    <div id="hud-layer" class="hidden">
        <div class="top-row">
            <div class="hud-panel" id="identity">
                <small style="color:#aaa">Du spielst:</small>
                <h2 id="my-name">---</h2>
                <div id="my-dot" style="width:100%; height:5px; background:gray; margin-top:5px;"></div>
            </div>
            
            <div class="hud-panel" style="text-align:center; min-width:100px;">
                <small style="color:#aaa">Zeit</small>
                <div id="timer-box">30</div>
            </div>

            <div class="hud-panel" id="turn-info" style="text-align:right;">
                <small style="color:#aaa">Am Zug:</small>
                <h2 id="turn-name" style="color:gold">---</h2>
            </div>
        </div>

        <div class="bottom-row">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div id="status-bar">Warte auf Spielstart...</div>
                <button id="btn-action" class="btn-horror" style="display:none;" onclick="game.roll()">WÜRFELN</button>
            </div>
        </div>
    </div>

    <!-- LOGIN -->
    <div id="login-screen" class="overlay">
        <h1 style="font-family:'Creepster'; font-size:5rem; color:red; margin:0; text-shadow:0 0 20px #000">HORROR LUDO</h1>
        <p style="color:#aaa; font-size:1.2rem;">Multiplayer Edition</p>
        <br>
        <input type="text" id="room-input" placeholder="Raum Name">
        <button class="btn-horror" onclick="join()">BEITRETEN</button>
    </div>

    <!-- LOBBY -->
    <div id="lobby-screen" class="overlay hidden">
        <h1 style="color:red; font-family:'Creepster'">Krypta Lobby</h1>
        <div id="lobby-list" style="font-size:1.5rem; margin-bottom:30px; text-align:center;"></div>
        <p style="color:#666" id="lobby-msg">Warte auf Spieler...</p>
        <button id="btn-start" class="btn-horror" onclick="start()" disabled>WARTEN...</button>
    </div>

    <!-- LOADING -->
    <div id="load-screen" class="overlay hidden">
        <h1 style="color:red; font-family:'Creepster'">Lade Welt...</h1>
        <div id="load-cont"><div id="load-bar"></div></div>
        <div id="load-txt">Init...</div>
        <button id="force-btn" style="display:none; margin-top:20px;" class="btn-horror" onclick="forceStart()">START ERZWINGEN</button>
    </div>

    <!-- QUIZ -->
    <div id="quiz-screen" class="overlay hidden">
        <h2 style="color:red; font-family:'Creepster'; font-size:3rem;">Todesfrage</h2>
        <p id="q-text" style="font-size:1.5rem;">?</p>
        <div id="q-opts"></div>
    </div>

    <script>
        document.getElementById('room-input').value = "Friedhof_" + Math.floor(Math.random()*1000);
        
        const socket = io();
        // Farben und Materialien
        const COLORS = { red: 0xaa0000, blue: 0x0000aa, green: 0x005500, yellow: 0xdddd00 };
        const QUESTIONS = [{q:"Killer in Halloween?", a:["Michael","Jason","Freddy"], c:0}, {q:"Regisseur Psycho?", a:["Hitchcock","Spielberg"], c:0}];

        let myData = { color:null, figure:null, isHost:false };
        let game = null;

        function join() {
            const r = document.getElementById('room-input').value;
            if(r) socket.emit('joinGame', r);
        }
        function start() {
            socket.emit('requestStartGame', document.getElementById('room-input').value);
        }
        function forceStart() {
            document.getElementById('load-screen').classList.add('hidden');
            document.getElementById('hud-layer').classList.remove('hidden');
        }

        socket.on('setIdentity', data => {
            myData = data;
            document.getElementById('my-name').innerText = data.figure;
            document.getElementById('my-name').style.color = '#'+COLORS[data.color].toString(16);
            document.getElementById('my-dot').style.background = '#'+COLORS[data.color].toString(16);
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        socket.on('youAreHost', () => { myData.isHost=true; updateLobby(); });

        socket.on('lobbyUpdate', data => {
            document.getElementById('lobby-list').innerHTML = data.players.map(p => 
                `<div style="color:${p.color}">${p.name} (${p.figure})</div>`
            ).join('');
            if(data.hostId === socket.id) myData.isHost = true;
            updateLobby();
        });

        function updateLobby() {
            const btn = document.getElementById('btn-start');
            const msg = document.getElementById('lobby-msg');
            if(myData.isHost) {
                btn.disabled=false; btn.innerText="SPIEL STARTEN";
                msg.innerText = "Du bist Host. Starte, wenn bereit.";
            } else {
                btn.disabled=true; btn.innerText="WARTEN AUF HOST";
                msg.innerText = "Der Host bereitet das Spiel vor...";
            }
        }

        socket.on('prepareGame', data => {
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('load-screen').classList.remove('hidden');
            runLoader(data);
        });

        socket.on('gameLive', () => {
            document.getElementById('load-screen').classList.add('hidden');
            document.getElementById('hud-layer').classList.remove('hidden');
        });

        async function runLoader(data) {
            const l = document.getElementById('load-txt');
            const b = document.getElementById('load-bar');
            const steps = ["Generiere Board...", "Lade Texturen...", "Baue Figuren...", "Fertig!"];
            
            try {
                for(let i=0; i<steps.length; i++) {
                    l.innerText = steps[i]; b.style.width=((i+1)*25)+"%";
                    await new Promise(r=>setTimeout(r, 600));
                }
                if(!game) game = new Game3D(data);
                l.innerText = "Warte auf Server Sync...";
                setTimeout(()=>document.getElementById('force-btn').style.display='block', 4000);
            } catch(e) {
                l.innerText = "FEHLER: " + e.message; l.style.color="red";
            }
        }

        socket.on('errorMsg', msg => alert(msg));


        // --- ENGINE ---
        class Game3D {
            constructor(data) {
                this.players = data.players;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.FogExp2(0x050505, 0.012);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.setCameraByColor(myData.color); // PERSÖNLICHE KAMERA

                const cvs = document.getElementById('game-canvas');
                this.renderer = new THREE.WebGLRenderer({antialias:true, canvas:cvs});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;

                // Licht
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(20,60,20); dir.castShadow=true;
                dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
                this.scene.add(dir);

                this.board = new Board(this.scene, data.trapFields);
                this.dice = new Dice(this.scene);
                this.pieces = [];
                this.initPieces();

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enablePan = false; 
                this.controls.maxPolarAngle = Math.PI / 2.2; // Nicht unter Boden gucken

                this.raycaster = new THREE.Raycaster();
                cvs.addEventListener('click', e => this.click(e));

                this.active = {}; this.rolled = null; this.rollCount = 0; this.tmr = null;
                this.socketListeners();
                this.loop();
            }

            // KAMERA LOGIK
            setCameraByColor(c) {
                // Setzt die Kamera so, dass das eigene Haus "unten" ist
                if(c === 'red') this.camera.position.set(0, 60, 50);      // Standard (Süden)
                else if(c === 'blue') this.camera.position.set(50, 60, 0); // Osten
                else if(c === 'green') this.camera.position.set(0, 60, -50); // Norden
                else if(c === 'yellow') this.camera.position.set(-50, 60, 0); // Westen
                else this.camera.position.set(0, 60, 50); // Fallback
                
                this.camera.lookAt(0,0,0);
            }

            initPieces() {
                ['red','blue','green','yellow'].forEach(c => {
                    for(let i=0;i<4;i++) this.pieces.push(new Piece(c,i,this.scene,this.board));
                });
            }

            socketListeners() {
                socket.on('turnChanged', d => {
                    this.active = d; this.rolled = null; this.rollCount = 0;
                    document.getElementById('turn-name').innerText = d.activeName;
                    document.getElementById('turn-name').style.color = '#'+COLORS[d.activeColor].toString(16);
                    this.timer(d.timeout);

                    // Automatisch Screens umschalten falls noch im Laden
                    document.getElementById('load-screen').classList.add('hidden');
                    document.getElementById('hud-layer').classList.remove('hidden');

                    const btn = document.getElementById('btn-action');
                    const msg = document.getElementById('status-bar');
                    
                    if(d.activeColor === myData.color) {
                        msg.innerText = "DU BIST DRAN!";
                        msg.style.color = "#0f0";
                        btn.style.display = 'inline-block'; btn.innerText = "WÜRFELN";
                    } else {
                        msg.innerText = d.activeName + " ist dran...";
                        msg.style.color = "#fff";
                        btn.style.display = 'none';
                    }
                    // Bot macht nur Server requests, client wartet
                });

                socket.on('statusMessage', d => document.getElementById('status-bar').innerText = d.msg);

                socket.on('diceRolled', d => {
                    clearInterval(this.tmr); document.getElementById('timer-box').innerText="-";
                    this.dice.anim(d.value, () => {
                        if(d.playerId === socket.id) this.handleRoll(d.value);
                        else document.getElementById('status-bar').innerText = this.active.activeName + " würfelt " + d.value;
                    });
                });

                socket.on('pieceMoved', d => {
                    const p = this.pieces.find(pc => pc.col===d.color && pc.idx===d.pieceId); // use d.color from server
                    if(!p) {
                        // Fallback: Nutze Active Color wenn Server keine Color sendet (bei Menschen)
                        const p2 = this.pieces.find(pc => pc.col===this.active.activeColor && pc.idx===d.pieceId);
                        if(p2) { p2.move(d.newPosition); this.checkKill(p2); }
                    } else {
                        p.move(d.newPosition); this.checkKill(p);
                    }
                });
            }

            handleRoll(val) {
                this.rolled = val; this.rollCount++;
                const btn = document.getElementById('btn-action');
                const msg = document.getElementById('status-bar');
                btn.style.display = 'none';
                msg.innerText = "Gewürfelt: " + val;

                const myPs = this.pieces.filter(p => p.col === myData.color);
                const allHome = myPs.every(p => p.pos === -1);

                if(allHome) {
                    if(val === 6) {
                        msg.innerText = "Eine 6! Ziehe raus!";
                    } else {
                        if(this.rollCount < 3) {
                            msg.innerText = `Versuch ${this.rollCount}/3.`;
                            btn.style.display = 'inline-block'; btn.innerText = "NOCHMAL";
                            this.rolled = null; return;
                        } else {
                            setTimeout(() => socket.emit('endTurn', {roomId:document.getElementById('room-input').value}), 1500);
                        }
                    }
                }
                
                if(!this.canMove()) {
                    setTimeout(() => {
                        msg.innerText = "Kein Zug möglich.";
                        setTimeout(() => socket.emit('endTurn', {roomId:document.getElementById('room-input').value}), 1500);
                    }, 1000);
                }
            }

            canMove() {
                return this.pieces.filter(p=>p.col===myData.color).some(p => {
                    if(p.pos===-1) return this.rolled===6;
                    return p.pos+this.rolled<=43;
                });
            }

            roll() { socket.emit('rollDice', {roomId:document.getElementById('room-input').value}); }

            click(e) {
                if(!this.rolled || this.active.activeColor!==myData.color) return;
                const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                this.raycaster.setFromCamera(m, this.camera);
                const hits = this.raycaster.intersectObjects(this.scene.children, true);
                for(let h of hits) {
                    let o = h.object; while(o.parent && !o.userData.p) o=o.parent;
                    if(o.userData.p && o.userData.p.col===myData.color) {
                        this.tryMove(o.userData.p); return;
                    }
                }
            }

            tryMove(p) {
                let n = -1;
                if(p.pos===-1) { if(this.rolled===6) n=0; else return; }
                else { n=p.pos+this.rolled; if(n>43) return; }

                const abs = this.board.abs(n, myData.color);
                socket.emit('movePiece', {roomId:document.getElementById('room-input').value, pieceId:p.idx, newPosition:n});
                
                if(this.board.isTrap(abs) && n<40) this.quiz(p);
                else this.finish();
            }

            finish() {
                if(this.rolled===6) {
                    this.rolled=null; this.rollCount=0;
                    document.getElementById('status-bar').innerText="6! Nochmal!";
                    const btn = document.getElementById('btn-action');
                    btn.style.display='inline-block'; btn.innerText="WÜRFELN";
                } else socket.emit('endTurn', {roomId:document.getElementById('room-input').value});
            }

            quiz(p) {
                const scr = document.getElementById('quiz-screen'); scr.classList.remove('hidden');
                const q = QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];
                document.getElementById('q-text').innerText=q.q;
                const div = document.getElementById('q-opts'); div.innerHTML='';
                q.a.forEach((a,i) => {
                    const b = document.createElement('div'); b.className='quiz-opt'; b.innerText=a;
                    b.onclick = () => {
                        scr.classList.add('hidden');
                        if(i===q.c) { alert("Richtig!"); this.finish(); }
                        else { 
                            alert("Falsch!"); 
                            socket.emit('movePiece', {roomId:document.getElementById('room-input').value, pieceId:p.idx, newPosition:-1});
                            socket.emit('endTurn', {roomId:document.getElementById('room-input').value});
                        }
                    };
                    div.appendChild(b);
                });
            }

            checkKill(atk) {
                if(atk.pos<0 || atk.pos>=40) return;
                const aPos = this.board.abs(atk.pos, atk.col);
                this.pieces.forEach(v => {
                    if(v!==atk && v.pos>=0 && v.pos<40 && this.board.abs(v.pos, v.col)===aPos) v.move(-1);
                });
            }

            timer(s) {
                if(this.tmr) clearInterval(this.tmr);
                let t=Math.floor(s); document.getElementById('timer-box').innerText=t;
                this.tmr=setInterval(()=>{ t--; document.getElementById('timer-box').innerText=t; if(t<=0) clearInterval(this.tmr);}, 1000);
            }
            loop() { requestAnimationFrame(()=>this.loop()); this.controls.update(); this.renderer.render(this.scene,this.camera); }
        }

        // --- PIECES ---
        class Piece {
            constructor(c,i,s,b) {
                this.col=c; this.idx=i; this.board=b; this.pos=-1;
                this.mesh=new THREE.Group(); this.mesh.userData={p:this};
                const mat = new THREE.MeshStandardMaterial({color:COLORS[c]});
                if(c==='red') { // Puppe
                    this.mesh.add(new THREE.Mesh(new THREE.ConeGeometry(0.7,1.5,16), mat).translateY(0.75));
                    this.mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color:0xffcccc})).translateY(1.6));
                } else if(c==='blue') { // Kreuz
                    this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,2,0.3), mat).translateY(1));
                    this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1.4,0.3,0.3), mat).translateY(1.3));
                } else if(c==='green') { // Stein
                    this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1,1.5,0.4), mat).translateY(0.75));
                    this.mesh.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.4,16), mat).rotateX(Math.PI/2).translateY(1.5));
                } else { // Geist
                    const gm = new THREE.MeshStandardMaterial({color:COLORS[c], transparent:true, opacity:0.7});
                    this.mesh.add(new THREE.Mesh(new THREE.CapsuleGeometry(0.5,1,4,8), gm).translateY(1));
                }
                s.add(this.mesh); this.move(-1,true);
            }
            move(p, instant) {
                this.pos=p; const t=this.board.pos(p,this.col,this.idx);
                if(instant) this.mesh.position.copy(t);
                else {
                    const s=this.mesh.position.clone(); let a=0;
                    const l=()=>{ a+=0.05; if(a>1)a=1; this.mesh.position.lerpVectors(s,t,a); this.mesh.position.y=Math.sin(a*Math.PI)*2; if(a<1)requestAnimationFrame(l); else this.mesh.position.y=0; };
                    l();
                }
            }
        }

        // --- BOARD ---
        class Board {
            constructor(s,t) { this.s=2.5; this.traps=t; this.scene=s; this.mk(); }
            mk() {
                const p = new THREE.Mesh(new THREE.BoxGeometry(60,1,60), new THREE.MeshStandardMaterial({color:0x221111}));
                p.position.y=-0.6; p.receiveShadow=true; this.scene.add(p);
                for(let i=0; i<40; i++) {
                    let col = this.traps.includes(i) ? 0xaa00aa : 0x444444;
                    if(i===0) col=COLORS.red; if(i===10) col=COLORS.blue; if(i===20) col=COLORS.green; if(i===30) col=COLORS.yellow;
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.3,0.2,2.3), new THREE.MeshStandardMaterial({color:col}));
                    m.position.copy(this.vec(i)); m.position.y=0.1; this.scene.add(m);
                    if(this.traps.includes(i)) {
                        const q = new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.4), new THREE.MeshBasicMaterial({color:0xff00ff}));
                        q.position.copy(m.position); q.position.y=0.6; this.scene.add(q);
                    }
                }
                ['red','blue','green','yellow'].forEach(c => {
                    let x=15, z=15; if(c==='blue') z=-15; if(c==='green'){x=-15;z=-15;} if(c==='yellow') x=-15;
                    const b = new THREE.Mesh(new THREE.CylinderGeometry(5,5,0.2,32), new THREE.MeshStandardMaterial({color:COLORS[c]}));
                    b.position.set(x,0.1,z); this.scene.add(b);
                });
                for(let s=1; s<=4; s++) {
                    this.safe('red',s,0); this.safe('blue',s,1); this.safe('green',s,2); this.safe('yellow',s,3);
                }
            }
            safe(c, step, rot) {
                 const v = new THREE.Vector3(0,0,(5-step)*this.s);
                 const ang = -rot*Math.PI/2;
                 const rx = v.x*Math.cos(ang)-v.z*Math.sin(ang); const rz = v.x*Math.sin(ang)+v.z*Math.cos(ang);
                 const m = new THREE.Mesh(new THREE.BoxGeometry(2,0.2,2), new THREE.MeshStandardMaterial({color:COLORS[c]}));
                 m.position.set(rx, 0.1, rz); this.scene.add(m);
            }
            vec(i) {
                const a=Math.floor(i/10), l=i%10; let x=0,z=0;
                if(l<5){x=1*this.s; z=(5-l)*this.s;} else {x=(l-3)*this.s; z=1*this.s;}
                const ang = -a*Math.PI/2;
                return new THREE.Vector3(x*Math.cos(ang)-z*Math.sin(ang), 0.1, x*Math.sin(ang)+z*Math.cos(ang));
            }
            abs(i,c){ let o=0; if(c==='blue')o=10; if(c==='green')o=20; if(c==='yellow')o=30; return (i+o)%40; }
            pos(i,c,idx) {
                if(i===-1) {
                    let x=15, z=15; if(c==='blue') z=-15; if(c==='green') {x=-15; z=-15;} if(c==='yellow') x=-15;
                    x += (idx%2===0?-1.5:1.5); z += (idx<2?-1.5:1.5);
                    return new THREE.Vector3(x,0,z);
                }
                if(i>=40) {
                     const st = i-40+1; const v = new THREE.Vector3(0,0,(5-st)*this.s);
                     let r=0; if(c==='blue')r=1; if(c==='green')r=2; if(c==='yellow')r=3;
                     const ang = -r*Math.PI/2;
                     return new THREE.Vector3(v.x*Math.cos(ang)-v.z*Math.sin(ang), 0, v.x*Math.sin(ang)+v.z*Math.cos(ang));
                }
                const v = this.vec(this.abs(i,c)); v.y=0; return v;
            }
            isTrap(a){return this.traps.includes(a);}
        }

        class Dice {
            constructor(s) {
                const g = new THREE.BoxGeometry(3,3,3); const m=[];
                for(let i=1;i<=6;i++){
                    const c=document.createElement('canvas');c.width=64;c.height=64;
                    const x=c.getContext('2d');x.fillStyle='#eee';x.fillRect(0,0,64,64);
                    x.fillStyle='red';x.font='40px Arial';x.textAlign='center';x.textBaseline='middle';x.fillText(i,32,32);
                    x.lineWidth=4;x.strokeRect(0,0,64,64);
                    m.push(new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(c)}));
                }
                this.m=new THREE.Mesh(g,m); this.m.position.set(0,5,0); s.add(this.m);
            }
            anim(v, cb) {
                let t=0; const i=setInterval(()=>{
                    this.m.rotation.x+=0.5; this.m.rotation.y+=0.5; t+=50;
                    if(t>800){clearInterval(i); this.m.rotation.set(0,0,0);
                    if(v===1)this.m.rotation.y=Math.PI/2; if(v===2)this.m.rotation.y=-Math.PI/2;
                    if(v===4)this.m.rotation.x=Math.PI; if(v===5)this.m.rotation.x=-Math.PI/2; if(v===6)this.m.rotation.x=Math.PI/2;
                    cb();}
                },50);
            }
        }
    </script>
</body>
</html>


