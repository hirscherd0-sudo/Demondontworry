<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horror Ludo Final</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #111; color: #eee; }
        
        /* UI Container - Klicks gehen durch, auÃŸer auf interaktive Elemente */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        
        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 20; pointer-events: auto;
        }
        .hidden { display: none !important; }

        h1 { font-family: 'Creepster', cursive; font-size: 3rem; color: #cc0000; text-shadow: 0 0 10px #000; }

        /* Buttons */
        button {
            background: #550000; border: 2px solid #990000; padding: 12px 25px; margin: 10px; 
            color: #fff; font-size: 1.2rem; cursor: pointer; border-radius: 5px;
            font-family: 'Creepster', cursive; transition: 0.2s;
        }
        button:hover { background: #770000; transform: scale(1.05); }
        button:disabled { background: #333; border-color: #555; color: #777; cursor: default; transform: none; }
        input { padding: 10px; background: #222; border: 1px solid #555; color: white; text-align: center; font-size: 1rem; }

        /* HUD Elements */
        #game-hud { display: none; }

        /* Timer - GroÃŸ und mittig */
        #timer-display {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Creepster', cursive; font-size: 5rem; color: #fff;
            text-shadow: 0 0 20px #cc0000;
            pointer-events: none;
        }

        /* Identity Box - Wer bin ich? */
        #identity-box {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.8); border: 2px solid #555; padding: 15px;
            border-radius: 10px; width: 200px;
        }
        #my-role { font-weight: bold; font-size: 1.2rem; font-family: 'Creepster', cursive; }

        /* Turn Info - Wer ist dran? */
        #turn-box {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); border: 2px solid #555; padding: 15px;
            border-radius: 10px; width: 200px; text-align: right;
        }
        #current-turn-name { font-weight: bold; color: #ffcc00; font-size: 1.2rem; }

        /* Status Text (Unten Mitte) */
        #status-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 10px 30px; border-radius: 20px;
            font-size: 1.2rem; border: 1px solid #444; text-align: center;
        }

        /* WÃ¼rfel Button (Fallback) */
        #dice-btn-fallback {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            z-index: 5; display: none;
        }

        /* Quiz */
        #quiz-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        .quiz-content { background: #222; border: 2px solid #cc0000; padding: 20px; width: 90%; max-width: 400px; text-align: center; }
        .quiz-opt { padding: 10px; margin: 5px 0; background: #333; border: 1px solid #555; cursor: pointer; }
        .quiz-opt:hover { background: #444; border-color: #cc0000; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="login-screen" class="screen interactive">
            <h1>Horror Ludo</h1>
            <input type="text" id="room-id" value="Krypta1" placeholder="Raum Name">
            <button onclick="connect()">Beitreten</button>
        </div>

        <!-- Lobby -->
        <div id="lobby-screen" class="screen interactive hidden">
            <h1>Lobby</h1>
            <div id="lobby-list" style="margin:20px; width:300px; background:#222; padding:10px;"></div>
            <button id="start-btn" onclick="startGame()" disabled>Spiel Starten</button>
        </div>

        <!-- Game HUD -->
        <div id="game-hud" class="hidden">
            <div id="timer-display">10</div>
            
            <div id="identity-box" class="interactive">
                <div>Du bist:</div>
                <div id="my-role" style="color:white">Zuschauer</div>
            </div>

            <div id="turn-box" class="interactive">
                <div>Am Zug:</div>
                <div id="current-turn-name">---</div>
            </div>

            <div id="status-bar">Warte auf Spielstart...</div>
            
            <button id="dice-btn-fallback" class="interactive" onclick="game.tryRollDice()">WÃœRFELN!</button>
        </div>

        <!-- Quiz -->
        <div id="quiz-modal" class="interactive">
            <div class="quiz-content">
                <h2 style="color:#cc0000">Todesfrage</h2>
                <p id="q-text">Frage...</p>
                <div id="q-opts"></div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        
        // Globals
        let myColor = null;
        let myFigure = null;
        let isMyTurn = false;
        let game = null;

        const COLORS = {
            red: 0xaa0000,
            blue: 0x0000aa,
            green: 0x005500,
            yellow: 0xdddd00
        };

        const QUESTIONS = [
            { q: "Killer in Halloween?", a: ["Michael Myers", "Jason", "Freddy"], c: 0 },
            { q: "Item gegen Geister?", a: ["Salz", "Zucker", "Pfeffer"], c: 0 },
            { q: "Clown in ES?", a: ["Pennywise", "Krusty", "Joker"], c: 0 },
            { q: "Zombies tÃ¶ten?", a: ["Kopfschuss", "Herzstich", "Nett fragen"], c: 0 },
            { q: "UnglÃ¼ckstag?", a: ["Freitag 13.", "Montag 1.", "Sonntag"], c: 0 }
        ];

        // --- CONNECT & LOBBY ---
        function connect() {
            const room = document.getElementById('room-id').value;
            socket.emit('joinGame', room);
        }

        function startGame() {
            const room = document.getElementById('room-id').value;
            socket.emit('requestStartGame', room);
        }

        socket.on('setIdentity', (data) => {
            myColor = data.color;
            myFigure = data.figure;
            
            const roleEl = document.getElementById('my-role');
            roleEl.innerText = `${data.figure} (${data.color})`;
            roleEl.style.color = '#' + COLORS[data.color].toString(16);

            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        socket.on('lobbyUpdate', (data) => {
            const list = document.getElementById('lobby-list');
            list.innerHTML = data.players.map(p => 
                `<div>${p.name} (${p.figure}) ${data.hostId===p.id?'ðŸ‘‘':''}</div>`
            ).join('');
            
            // Host Button Logic
            const btn = document.getElementById('start-btn');
            if(data.hostId === socket.id) {
                btn.disabled = false;
                btn.innerText = "STARTEN";
            } else {
                btn.disabled = true;
                btn.innerText = "Warte auf Host...";
            }
        });

        socket.on('gameStarted', (data) => {
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-hud').style.display = 'block';
            if(!game) game = new Game3D(data.players, data.trapFields);
        });

        socket.on('errorMsg', (msg) => alert(msg));

        // --- 3D ENGINE ---
        class Game3D {
            constructor(players, trapFields) {
                this.players = players;
                this.trapFields = trapFields;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);
                
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 45, 30);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement); // Canvas ist hinter UI

                // Raycaster Setup auf Canvas
                this.raycaster = new THREE.Raycaster();
                // WICHTIG: Klick Listener direkt aufs Canvas
                this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                
                // Licht
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(10, 40, 10);
                this.scene.add(dir);

                // Objekte
                this.dice = new Dice(this.scene);
                this.board = new Board(this.scene, this.trapFields);
                this.pieces = [];
                this.initPieces();

                // State
                this.turnColor = '';
                this.rolledValue = null;
                this.hasRolled = false;
                this.timerInt = null;

                this.setupSocket();
                this.animate();
            }

            initPieces() {
                ['red', 'blue', 'green', 'yellow'].forEach(c => {
                    for(let i=0; i<4; i++) {
                        this.pieces.push(new Piece(c, i, this.scene, this.board));
                    }
                });
            }

            setupSocket() {
                socket.on('turnChanged', (data) => {
                    this.turnColor = data.activeColor;
                    this.hasRolled = false;
                    this.rolledValue = null;
                    isMyTurn = (data.activeColor === myColor);

                    // UI Update
                    document.getElementById('current-turn-name').innerText = data.activeName;
                    document.getElementById('current-turn-name').style.color = '#' + COLORS[data.activeColor].toString(16);
                    
                    const status = document.getElementById('status-bar');
                    const btn = document.getElementById('dice-btn-fallback');
                    
                    if(isMyTurn) {
                        status.innerText = "DU BIST DRAN! Tippe den WÃ¼rfel an!";
                        status.style.color = "#00ff00";
                        btn.style.display = 'block'; // Fallback Button falls 3D Klick nicht geht
                    } else {
                        status.innerText = `${data.activeName} ist am Zug...`;
                        status.style.color = "#fff";
                        btn.style.display = 'none';
                    }

                    // Timer Start
                    this.startTimer(10);

                    // Bot Move Trigger (Nur Host simuliert Bot WÃ¼rfelwurf, oder Server logic. 
                    // Hier vereinfacht: Server Timer erzwingt Zugende, Bot macht visuell nix auÃŸer Server wÃ¼rfelt fÃ¼r ihn)
                    // Wenn wir wollen dass Bot wÃ¼rfelt, muss der Client der Host ist das emitten
                    if(data.isBot && this.amIHost()) {
                        setTimeout(() => socket.emit('rollDice', { roomId: document.getElementById('room-id').value }), 1000);
                    }
                });

                socket.on('statusMessage', (data) => {
                    document.getElementById('status-bar').innerText = data.msg;
                });

                socket.on('diceRolled', (data) => {
                    clearInterval(this.timerInt);
                    document.getElementById('timer-display').innerText = "-";
                    
                    this.dice.roll(data.value, () => {
                        if(data.playerId === socket.id) {
                            this.rolledValue = data.value;
                            this.hasRolled = true;
                            document.getElementById('status-bar').innerText = `Du hast eine ${data.value}. WÃ¤hle eine Figur!`;
                            document.getElementById('dice-btn-fallback').style.display = 'none';

                            // Auto-Pass Check
                            if(!this.canMove()) {
                                setTimeout(() => {
                                    document.getElementById('status-bar').innerText = "Kein Zug mÃ¶glich...";
                                    setTimeout(() => socket.emit('endTurn', { roomId: document.getElementById('room-id').value }), 1000);
                                }, 1000);
                            }
                        } else {
                            document.getElementById('status-bar').innerText = `${this.turnColor} hat ${data.value} gewÃ¼rfelt.`;
                        }
                    });
                });

                socket.on('pieceMoved', (data) => {
                    const p = this.pieces.find(pc => pc.color === this.turnColor && pc.index === data.pieceId);
                    if(p) {
                        p.move(data.newPosition);
                        this.checkKills(p);
                    }
                });
            }

            amIHost() {
                // Einfacher Check: Bin ich der erste in der Liste? (Nicht 100% sicher aber reicht fÃ¼r Demo)
                // Besser: Socket speichert Host Info.
                // Wir haben isHost in setIdentity bekommen, speichern wir es global?
                // Vereinfachung: Server regelt Bot Timeout.
                return true; 
            }

            startTimer(sec) {
                if(this.timerInt) clearInterval(this.timerInt);
                let t = sec;
                const el = document.getElementById('timer-display');
                el.innerText = t;
                this.timerInt = setInterval(() => {
                    t--;
                    el.innerText = t;
                    if(t<=0) clearInterval(this.timerInt);
                }, 1000);
            }

            canMove() {
                return this.pieces.filter(p => p.color === myColor).some(p => {
                    if(p.pos === -1) return this.rolledValue === 6;
                    return p.pos + this.rolledValue <= 43; // 43 ist letztes Zielfeld
                });
            }

            tryRollDice() {
                if(!isMyTurn || this.hasRolled) return;
                socket.emit('rollDice', { roomId: document.getElementById('room-id').value });
            }

            onClick(e) {
                // Raycasting logic
                if(!isMyTurn) return;

                const mouse = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
                this.raycaster.setFromCamera(mouse, this.camera);

                // 1. WÃ¼rfel
                const diceIntersects = this.raycaster.intersectObject(this.dice.mesh);
                if(diceIntersects.length > 0 && !this.hasRolled) {
                    this.tryRollDice();
                    return;
                }

                // 2. Figuren
                if(this.hasRolled) {
                    const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                    for(let hit of intersects) {
                        let obj = hit.object;
                        while(obj.parent && !obj.userData.piece) obj = obj.parent;
                        
                        if(obj.userData.piece) {
                            const p = obj.userData.piece;
                            if(p.color === myColor) {
                                this.tryMovePiece(p);
                                return;
                            }
                        }
                    }
                }
            }

            tryMovePiece(p) {
                let target = -1;
                if(p.pos === -1) {
                    if(this.rolledValue === 6) target = 0; else return;
                } else {
                    target = p.pos + this.rolledValue;
                    if(target > 43) return;
                }

                const absPos = this.board.getAbsPos(target, myColor);
                socket.emit('movePiece', { 
                    roomId: document.getElementById('room-id').value, 
                    pieceId: p.index, 
                    newPosition: target 
                });

                if(this.board.isTrap(absPos) && target < 40) {
                    this.showQuiz(p);
                } else {
                    this.endTurnLogic();
                }
            }

            showQuiz(p) {
                const m = document.getElementById('quiz-modal');
                const t = document.getElementById('q-text');
                const o = document.getElementById('q-opts');
                const q = QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];
                
                t.innerText = q.q; o.innerHTML = '';
                q.a.forEach((ans, i) => {
                    const b = document.createElement('div');
                    b.className = 'quiz-opt'; b.innerText = ans;
                    b.onclick = () => {
                        m.style.display = 'none';
                        if(i === q.c) {
                            alert("Richtig! Noch mal!");
                            this.hasRolled = false; // Noch mal wÃ¼rfeln
                            document.getElementById('status-bar').innerText = "Richtig! WÃ¼rfle nochmal!";
                            document.getElementById('dice-btn-fallback').style.display = 'block';
                        } else {
                            alert("Falsch! ZurÃ¼ck!");
                            socket.emit('movePiece', { 
                                roomId: document.getElementById('room-id').value, 
                                pieceId: p.index, 
                                newPosition: -1 
                            });
                            this.endTurnLogic(false);
                        }
                    };
                    o.appendChild(b);
                });
                m.style.display = 'flex';
            }

            endTurnLogic(extra = true) {
                if(extra && this.rolledValue === 6) {
                    this.hasRolled = false;
                    document.getElementById('status-bar').innerText = "Eine 6! WÃ¼rfle nochmal.";
                    document.getElementById('dice-btn-fallback').style.display = 'block';
                } else {
                    socket.emit('endTurn', { roomId: document.getElementById('room-id').value });
                }
            }

            checkKills(movedP) {
                // Visuell vereinfacht. Echte Logik mÃ¼sste Serverseitig sein.
                // Wir checken hier ob eine Figur visuell auf dem gleichen Feld steht
                // Achtung: Funktioniert nur wenn Positionen up to date sind
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // --- DICE OBJECT ---
        class Dice {
            constructor(scene) {
                const geo = new THREE.BoxGeometry(4, 4, 4); // GroÃŸ!
                // Einfache Farben fÃ¼r sichtbarkeit
                const mats = [
                    this.mat(1), this.mat(2), this.mat(3),
                    this.mat(4), this.mat(5), this.mat(6)
                ];
                this.mesh = new THREE.Mesh(geo, mats);
                this.mesh.position.set(0, 5, 0);
                scene.add(this.mesh);
            }
            mat(n) {
                const cvs = document.createElement('canvas');
                cvs.width = 64; cvs.height = 64;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = '#ffeba7'; ctx.fillRect(0,0,64,64);
                ctx.lineWidth = 5; ctx.strokeStyle='#8b0000'; ctx.strokeRect(0,0,64,64);
                ctx.fillStyle = '#8b0000'; ctx.font = '40px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(n, 32, 32);
                return new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(cvs) });
            }
            roll(val, cb) {
                let t = 0;
                const iv = setInterval(() => {
                    this.mesh.rotation.x += 0.5; this.mesh.rotation.z += 0.5;
                    t+=100;
                    if(t>1000) {
                        clearInterval(iv);
                        // Reset rotation to show face
                        this.mesh.rotation.set(0,0,0);
                        // Val Mapping (Simple: Textur ist fix, wir zeigen einfach irgendeine seite oben)
                        // Da Texturen hardcoded sind:
                        // 1=Right(x+), 2=Left(x-), 3=Top(y+), 4=Bot(y-), 5=Front(z+), 6=Back(z-)
                        // Wir rotieren so dass die gewÃ¼nschte Seite Oben (Y+) ist.
                        // Default ist 3 Oben.
                        if(val===1) this.mesh.rotation.z = Math.PI/2;
                        if(val===2) this.mesh.rotation.z = -Math.PI/2;
                        if(val===4) this.mesh.rotation.x = Math.PI;
                        if(val===5) this.mesh.rotation.x = -Math.PI/2;
                        if(val===6) this.mesh.rotation.x = Math.PI/2;
                        if(cb) cb();
                    }
                }, 50);
            }
        }

        // --- BOARD LOGIC (KREUZ) ---
        class Board {
            constructor(scene, trapFields) {
                this.scene = scene;
                this.trapFields = trapFields;
                this.createTiles();
            }
            createTiles() {
                // Boden
                const p = new THREE.Mesh(new THREE.BoxGeometry(60,1,60), new THREE.MeshStandardMaterial({color:0x000000}));
                p.position.y = -2; this.scene.add(p);
                
                // 40 Felder Kreuz. Wir nutzen einfache Vektoren.
                for(let i=0; i<40; i++) {
                    const pos = this.getVec(i);
                    const isTrap = this.trapFields.includes(i);
                    const mat = new THREE.MeshStandardMaterial({ color: isTrap?0xff00ff:0x555555 });
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 2.2), mat);
                    m.position.copy(pos);
                    this.scene.add(m);
                    if(isTrap) {
                        const q = new THREE.Mesh(new THREE.BoxGeometry(0.5,2,0.5), new THREE.MeshBasicMaterial({color:0xff00ff}));
                        q.position.set(pos.x, 1, pos.z); this.scene.add(q);
                    }
                }
                // Homes
                this.createHome('red'); this.createHome('blue'); this.createHome('green'); this.createHome('yellow');
            }
            getVec(i) {
                // Index 0 = Start Rot (Unten Rechts von Mitte)
                // Center 0,0. Scale 2.5
                const S = 2.5;
                // Hardcoded Path Segments for correct shape
                // 0-4 (Unten hoch), 5-9 (Rechts raus)...
                // Um es einfach zu machen: Eine Lookup Funktion fÃ¼r einen Arm (0-9)
                const arm = Math.floor(i/10);
                const loc = i%10;
                let x=0, z=0;
                
                // Arm 0 (Unten): 0=(S, 5S) ... 4=(S, S) ... 5=(2S, S) ... 9=(6S, S) ???
                // Ludo Shape:
                // Arm hat 3 Spalten. Pfad ist auÃŸen.
                // Arm 0 (Unten): Rechte Spalte hoch (0-4), dann Ecke nach Rechts (5-9 ist nÃ¤chster Arm)
                // Stop. 0-9 ist ein Spieler Segment.
                // 0-4: Auf dem Arm hoch. (1, 5) -> (1, 1)
                // 5-9: Auf dem nÃ¤chsten Arm raus. (2, 1) -> (6, 1)
                
                if(loc < 5) { x=1*S; z=(5-loc)*S; } // (2.5, 12.5) -> (2.5, 2.5)
                else { x=(loc-3)*S; z=1*S; } // (5, 2.5) -> (15, 2.5)
                
                // Rotation
                const ang = -arm * Math.PI/2;
                const rx = x*Math.cos(ang) - z*Math.sin(ang);
                const rz = x*Math.sin(ang) + z*Math.cos(ang);
                return new THREE.Vector3(rx, -1, rz);
            }
            createHome(c) {
                // Bases
                let cx=15, cz=15;
                if(c==='blue') cz=-15; if(c==='green') {cx=-15; cz=-15;} if(c==='yellow') cx=-15;
                const m = new THREE.Mesh(new THREE.CylinderGeometry(5,5,0.5,32), new THREE.MeshStandardMaterial({color:COLORS[c]}));
                m.position.set(cx, -1, cz); this.scene.add(m);
            }
            getAbsPos(idx, c) {
                let off=0;
                if(c==='blue') off=10; if(c==='green') off=20; if(c==='yellow') off=30;
                return (idx+off)%40;
            }
            isTrap(absIdx) { return this.trapFields.includes(absIdx); }
            
            getPos(idx, c) {
                if(idx===-1) {
                    let cx=15, cz=15; // Red Base
                    if(c==='blue') cz=-15; if(c==='green') {cx=-15; cz=-15;} if(c==='yellow') cx=-15;
                    return new THREE.Vector3(cx, 0, cz); // Center of base
                }
                if(idx >= 40) {
                    // Home Ziel (Mitte Arm)
                    const S = 2.5;
                    const step = idx-40+1;
                    const v = new THREE.Vector3(0, -1, (5-step)*S);
                    let rot=0;
                    if(c==='blue') rot=1; if(c==='green') rot=2; if(c==='yellow') rot=3;
                    const ang = -rot*Math.PI/2;
                    const rx = v.x*Math.cos(ang) - v.z*Math.sin(ang);
                    const rz = v.x*Math.sin(ang) + v.z*Math.cos(ang);
                    return new THREE.Vector3(rx, 0, rz);
                }
                const abs = this.getAbsPos(idx, c);
                const v = this.getVec(abs);
                v.y = 0;
                return v;
            }
        }

        class Piece {
            constructor(c, i, s, b) {
                this.color=c; this.index=i; this.board=b; this.pos=-1;
                this.mesh = new THREE.Group();
                this.mesh.userData = { piece: this };
                
                // Simple shapes
                const mat = new THREE.MeshStandardMaterial({color:COLORS[c]});
                if(c==='red') this.mesh.add(new THREE.Mesh(new THREE.ConeGeometry(0.8,2,16), mat)); // Puppe
                if(c==='blue') this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1,2,0.5), mat)); // Kreuz
                if(c==='green') this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,1.5,0.5), mat)); // Grab
                if(c==='yellow') this.mesh.add(new THREE.Mesh(new THREE.SphereGeometry(1), mat)); // Geist
                
                s.add(this.mesh);
                this.move(-1, true);
            }
            move(p, instant) {
                this.pos = p;
                const t = this.board.getPos(p, this.color);
                // Offset damit sie nicht ineinander stehen auf Base
                if(p===-1) {
                    t.x += (this.index%2===0?-1.5:1.5);
                    t.z += (this.index<2?-1.5:1.5);
                }
                t.y = 1; // HÃ¶he
                this.mesh.position.copy(t);
            }
        }
    </script>
</body>
</html>


