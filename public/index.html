<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horror Ludo - Final</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; color: #eee; font-family: 'Roboto', sans-serif; }

        /* LAYER 0: 3D CANVAS */
        #game-canvas {
            display: block; position: absolute; top: 0; left: 0; z-index: 0;
        }

        /* LAYER 1: HUD (UI) */
        #hud-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; /* Klicks gehen durch */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-panel {
            background: rgba(30, 0, 0, 0.9); border: 2px solid #aa0000;
            padding: 15px; margin: 20px; border-radius: 8px; 
            pointer-events: auto; /* Panel ist klickbar/blockt Raycast */
            box-shadow: 0 0 20px #000;
        }

        .top-row { display: flex; justify-content: space-between; }
        #identity h2, #turn-info h2 { font-family: 'Creepster', cursive; margin: 0; font-size: 1.8rem; }
        #timer-box { font-size: 3.5rem; color: red; font-weight: bold; text-align: right; text-shadow: 0 0 10px red; }

        .bottom-row { display: flex; justify-content: center; padding-bottom: 40px; pointer-events: auto; }
        #status-msg { 
            background: rgba(0,0,0,0.85); padding: 10px 30px; border-radius: 30px; 
            font-size: 1.6rem; margin-bottom: 15px; text-align: center; border: 1px solid #666;
            color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000;
        }

        .btn-horror {
            background: #880000; color: white; border: 3px solid #ff0000;
            padding: 15px 50px; font-size: 2rem; font-family: 'Creepster', cursive;
            cursor: pointer; display: block; margin: 0 auto; box-shadow: 0 0 30px red;
            border-radius: 10px; transition: transform 0.1s;
        }
        .btn-horror:hover { background: #aa0000; transform: scale(1.1); }
        .btn-horror:disabled { background: #333; border-color: #555; color: #777; box-shadow: none; transform: none; }

        /* LAYER 2: OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 5, 5, 0.98); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .hidden { display: none !important; }

        input { padding: 15px; font-size: 1.5rem; text-align: center; background: #222; color: white; border: 2px solid #555; margin-bottom: 30px; width: 300px; }
        
        .quiz-opt {
            background: #222; padding: 20px; margin: 10px; width: 400px; border: 1px solid #555; cursor: pointer; text-align: left; font-size: 1.2rem;
        }
        .quiz-opt:hover { border-color: red; background: #550000; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <!-- HUD -->
    <div id="hud-container">
        <div class="top-row">
            <div class="hud-panel" id="identity">
                <small style="color:#aaa">Deine Rolle:</small>
                <h2 id="my-name">---</h2>
                <div id="my-dot" style="width:100%; height:8px; background:gray; margin-top:5px;"></div>
            </div>
            <div class="hud-panel" id="turn-info" style="text-align:right;">
                <small style="color:#aaa">Am Zug:</small>
                <h2 id="turn-name" style="color:gold">---</h2>
                <div id="timer-box">25</div>
            </div>
        </div>
        <div class="bottom-row">
            <div>
                <div id="status-msg">Warte auf Spielstart...</div>
                <button id="btn-action" class="btn-horror" style="display:none;" onclick="game.roll()">WÜRFELN</button>
            </div>
        </div>
    </div>

    <!-- SCREENS -->
    <div id="login-screen" class="overlay">
        <h1 style="font-family:'Creepster'; font-size:6rem; color:red; margin:0; text-shadow: 0 0 20px #000;">HORROR LUDO</h1>
        <p style="color:#888; margin-bottom: 40px; font-size: 1.2rem;">Todeszone Edition</p>
        <input type="text" id="room-input" placeholder="Raum Name">
        <button class="btn-horror" onclick="join()">EINTRETEN</button>
    </div>

    <div id="lobby-screen" class="overlay hidden">
        <h1 style="color:red; font-family:'Creepster'">Die Krypta</h1>
        <div id="lobby-list" style="font-size:1.8rem; margin-bottom:40px; text-align:center;"></div>
        <button id="btn-start" class="btn-horror" onclick="start()" disabled>WARTEN...</button>
    </div>

    <div id="quiz-screen" class="overlay hidden">
        <h2 style="color:red; font-family:'Creepster'; font-size:4rem;">TODESFRAGE</h2>
        <p id="q-text" style="font-size:1.8rem; margin-bottom:30px; text-align:center;">?</p>
        <div id="q-opts"></div>
    </div>

    <script>
        // Default Room Name
        document.getElementById('room-input').value = "Friedhof_" + Math.floor(Math.random()*1000);
        
        const socket = io();
        const COLORS = { red: 0xcc0000, blue: 0x0000cc, green: 0x008800, yellow: 0xeeee00 };
        const QUESTIONS = [
            {q:"Killer in Halloween?", a:["Michael Myers","Jason","Freddy"], c:0},
            {q:"Regisseur von Psycho?", a:["Hitchcock","Spielberg","Lucas"], c:0},
            {q:"Angst vor Spinnen?", a:["Arachnophobie","Klaustrophobie","Agoraphobie"], c:0},
            {q:"Clown in ES?", a:["Pennywise","Joker","Krusty"], c:0}
        ];

        let myData = { color:null, figure:null };
        let game = null;

        function join() {
            const r = document.getElementById('room-input').value;
            if(r) socket.emit('joinGame', r);
        }
        function start() {
            socket.emit('requestStartGame', document.getElementById('room-input').value);
        }

        socket.on('setIdentity', data => {
            myData = data;
            document.getElementById('my-name').innerText = data.figure;
            document.getElementById('my-name').style.color = '#'+COLORS[data.color].toString(16);
            document.getElementById('my-dot').style.background = '#'+COLORS[data.color].toString(16);
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        socket.on('youAreHost', () => {
            const btn = document.getElementById('btn-start');
            btn.disabled = false; btn.innerText = "STARTEN";
        });

        socket.on('lobbyUpdate', data => {
            document.getElementById('lobby-list').innerHTML = data.players.map(p => 
                `<div style="color:${p.color}; margin: 5px;">${p.name} <span style="font-size:0.8em; color:#666">(${p.figure})</span></div>`
            ).join('');
            
            if(data.hostId === socket.id) {
                const btn = document.getElementById('btn-start');
                btn.disabled = false; btn.innerText = "STARTEN";
            }
        });

        socket.on('gameStarted', data => {
            document.getElementById('lobby-screen').classList.add('hidden');
            if(!game) game = new Game3D(data);
        });

        socket.on('errorMsg', msg => alert(msg));


        // --- GAME ENGINE ---
        class Game3D {
            constructor(data) {
                this.players = data.players;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050000);
                this.scene.fog = new THREE.FogExp2(0x050000, 0.015);
                
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 50, 40);
                this.camera.lookAt(0,0,0);

                this.renderer = new THREE.WebGLRenderer({antialias:true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.domElement.id = "game-canvas"; // ID für CSS
                document.body.appendChild(this.renderer.domElement);

                // Lighting
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(20,50,20); dir.castShadow=true;
                dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
                this.scene.add(dir);
                
                const spotR = new THREE.PointLight(0xff0000, 0.5, 40); spotR.position.set(-15,10,-15); this.scene.add(spotR);
                const spotB = new THREE.PointLight(0x0000ff, 0.5, 40); spotB.position.set(15,10,15); this.scene.add(spotB);

                this.board = new Board(this.scene, data.trapFields);
                this.dice = new Dice(this.scene);
                this.pieces = [];
                this.initPieces();

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.raycaster = new THREE.Raycaster();
                this.renderer.domElement.addEventListener('click', e => this.click(e));

                this.active = {};
                this.rolled = null;
                this.rollCount = 0;
                this.tmr = null;

                this.socketListeners();
                this.loop();
            }

            initPieces() {
                ['red','blue','green','yellow'].forEach(c => {
                    for(let i=0;i<4;i++) this.pieces.push(new Piece(c,i,this.scene,this.board));
                });
            }

            socketListeners() {
                socket.on('turnChanged', d => {
                    this.active = d; this.rolled = null; this.rollCount = 0;
                    document.getElementById('turn-name').innerText = d.activeName;
                    document.getElementById('turn-name').style.color = '#'+COLORS[d.activeColor].toString(16);
                    this.timer(d.timeout);

                    const btn = document.getElementById('btn-action');
                    if(d.activeColor === myData.color) {
                        document.getElementById('status-msg').innerText = "DU BIST DRAN!";
                        document.getElementById('status-msg').style.color = "#0f0";
                        btn.style.display = 'inline-block';
                        btn.innerText = "WÜRFELN";
                    } else {
                        document.getElementById('status-msg').innerText = d.activeName + " überlegt...";
                        document.getElementById('status-msg').style.color = "#fff";
                        btn.style.display = 'none';
                    }
                    if(d.isBot && myData.isHost) setTimeout(()=>socket.emit('rollDice', {roomId:document.getElementById('room-input').value}), 1500);
                });

                socket.on('statusMessage', d => document.getElementById('status-msg').innerText = d.msg);

                socket.on('diceRolled', d => {
                    clearInterval(this.tmr); document.getElementById('timer-box').innerText="-";
                    this.dice.anim(d.value, () => {
                        if(d.playerId === socket.id) this.handleRoll(d.value);
                        else document.getElementById('status-msg').innerText = this.active.activeName + " hat " + d.value;
                    });
                });

                socket.on('pieceMoved', d => {
                    const p = this.pieces.find(pc => pc.col===this.active.activeColor && pc.idx===d.pieceId);
                    if(p) { p.move(d.newPosition); this.checkKill(p); }
                });
            }

            handleRoll(val) {
                this.rolled = val; this.rollCount++;
                const btn = document.getElementById('btn-action');
                btn.style.display = 'none';
                document.getElementById('status-msg').innerText = "Gewürfelt: " + val;

                const myPs = this.pieces.filter(p => p.col === myData.color);
                const allHome = myPs.every(p => p.pos === -1);

                if(allHome) {
                    if(val === 6) {
                        document.getElementById('status-msg').innerText = "Eine 6! Ziehe raus!";
                        // Muss raus
                    } else {
                        if(this.rollCount < 3) {
                            document.getElementById('status-msg').innerText = "Keine 6. Versuch " + this.rollCount + "/3";
                            btn.style.display = 'inline-block'; btn.innerText = "NOCHMAL";
                            this.rolled = null; 
                            return; 
                        } else {
                            setTimeout(() => socket.emit('endTurn', {roomId:document.getElementById('room-input').value}), 1500);
                        }
                    }
                }

                if(!this.canMove()) {
                    setTimeout(() => {
                        document.getElementById('status-msg').innerText = "Kein Zug möglich.";
                        setTimeout(() => socket.emit('endTurn', {roomId:document.getElementById('room-input').value}), 1000);
                    }, 1000);
                }
            }

            canMove() {
                return this.pieces.filter(p=>p.col===myData.color).some(p => {
                    if(p.pos===-1) return this.rolled===6;
                    return p.pos+this.rolled<=43;
                });
            }

            roll() { socket.emit('rollDice', {roomId:document.getElementById('room-input').value}); }

            click(e) {
                if(!this.rolled || this.active.activeColor!==myData.color) return;
                const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                this.raycaster.setFromCamera(m, this.camera);
                const hits = this.raycaster.intersectObjects(this.scene.children, true);
                for(let h of hits) {
                    let o = h.object; while(o.parent && !o.userData.p) o=o.parent;
                    if(o.userData.p && o.userData.p.col===myData.color) {
                        this.tryMove(o.userData.p); return;
                    }
                }
            }

            tryMove(p) {
                let n = -1;
                if(p.pos===-1) { if(this.rolled===6) n=0; else return; }
                else { n=p.pos+this.rolled; if(n>43) return; }

                const abs = this.board.abs(n, myData.color);
                socket.emit('movePiece', {roomId:document.getElementById('room-input').value, pieceId:p.idx, newPosition:n});
                
                if(this.board.isTrap(abs) && n<40) this.quiz(p);
                else this.finish();
            }

            finish() {
                if(this.rolled===6) {
                    this.rolled=null; this.rollCount=0;
                    document.getElementById('status-msg').innerText="6! Nochmal!";
                    document.getElementById('btn-action').style.display='inline-block';
                    document.getElementById('btn-action').innerText="WÜRFELN";
                } else socket.emit('endTurn', {roomId:document.getElementById('room-input').value});
            }

            quiz(p) {
                const scr = document.getElementById('quiz-screen'); scr.classList.remove('hidden');
                const q = QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];
                document.getElementById('q-text').innerText=q.q;
                const div = document.getElementById('q-opts'); div.innerHTML='';
                q.a.forEach((a,i) => {
                    const b = document.createElement('div'); b.className='quiz-opt'; b.innerText=a;
                    b.onclick = () => {
                        scr.classList.add('hidden');
                        if(i===q.c) { alert("Richtig!"); this.finish(); }
                        else { 
                            alert("Falsch!"); 
                            socket.emit('movePiece', {roomId:document.getElementById('room-input').value, pieceId:p.idx, newPosition:-1});
                            socket.emit('endTurn', {roomId:document.getElementById('room-input').value});
                        }
                    };
                    div.appendChild(b);
                });
            }

            checkKill(atk) {
                if(atk.pos<0 || atk.pos>=40) return;
                const aPos = this.board.abs(atk.pos, atk.col);
                this.pieces.forEach(v => {
                    if(v!==atk && v.pos>=0 && v.pos<40 && this.board.abs(v.pos, v.col)===aPos) v.move(-1);
                });
            }

            timer(s) {
                if(this.tmr) clearInterval(this.tmr);
                let t=Math.floor(s); document.getElementById('timer-box').innerText=t;
                this.tmr=setInterval(()=>{ t--; document.getElementById('timer-box').innerText=t; if(t<=0) clearInterval(this.tmr);}, 1000);
            }
            loop() { requestAnimationFrame(()=>this.loop()); this.controls.update(); this.renderer.render(this.scene,this.camera); }
        }

        // --- MODELS (HIGH DETAIL) ---
        class Piece {
            constructor(c,i,s,b) {
                this.col=c; this.idx=i; this.board=b; this.pos=-1;
                this.mesh=new THREE.Group(); this.mesh.userData={p:this};
                
                if(c==='red') this.buildDoll();
                else if(c==='blue') this.buildCross();
                else if(c==='green') this.buildStone();
                else if(c==='yellow') this.buildGhost();
                
                s.add(this.mesh); this.move(-1,true);
            }
            buildDoll() {
                const mD=new THREE.MeshStandardMaterial({color:0xaa0000}), mS=new THREE.MeshStandardMaterial({color:0xeee});
                this.mesh.add(new THREE.Mesh(new THREE.ConeGeometry(0.7,1.5,16), mD).translateY(0.75));
                this.mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.4), mS).translateY(1.6));
                const hair=new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({color:0x331100}));
                this.mesh.add(hair.clone().translateY(1.7).translateX(-0.35)); this.mesh.add(hair.clone().translateY(1.7).translateX(0.35));
            }
            buildCross() {
                const m=new THREE.MeshStandardMaterial({color:0x443322});
                this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,2,0.3), m).translateY(1));
                this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1.4,0.35,0.3), m).translateY(1.3).rotateZ(-0.1));
            }
            buildStone() {
                const m=new THREE.MeshStandardMaterial({color:0x556655});
                this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(1,1.5,0.4), m).translateY(0.75));
                this.mesh.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.4,16), m).translateY(1.5).rotateX(Math.PI/2));
                const rip=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.15,0.42), new THREE.MeshBasicMaterial({color:0}));
                rip.position.set(0,1.2,0); this.mesh.add(rip);
            }
            buildGhost() {
                const m=new THREE.MeshStandardMaterial({color:0xffffaa, transparent:true, opacity:0.8});
                this.mesh.add(new THREE.Mesh(new THREE.CapsuleGeometry(0.5,1,4,8), m).translateY(1));
                const eye=new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color:0}));
                this.mesh.add(eye.clone().position.set(-0.2,1.3,0.4)); this.mesh.add(eye.clone().position.set(0.2,1.3,0.4));
            }
            move(p, instant) {
                this.pos=p; const t = this.board.pos(p, this.col, this.idx);
                if(instant) this.mesh.position.copy(t);
                else {
                    const s=this.mesh.position.clone(); let a=0;
                    const l=()=>{ a+=0.05; if(a>1)a=1; this.mesh.position.lerpVectors(s,t,a); this.mesh.position.y=Math.sin(a*Math.PI)*2; if(a<1)requestAnimationFrame(l); else this.mesh.position.y=0; };
                    l();
                }
            }
        }

        // --- BOARD ---
        class Board {
            constructor(s,t) { this.s=2.5; this.traps=t; this.mk(); }
            mk() {
                // Boden
                const p = new THREE.Mesh(new THREE.BoxGeometry(60,1,60), new THREE.MeshStandardMaterial({color:0x221111}));
                p.position.y=-0.6; p.receiveShadow=true; this.s.add(p);
                
                // Pfad (0-39)
                for(let i=0; i<40; i++) {
                    let col = this.traps.includes(i) ? 0xaa00aa : 0x444444;
                    // Startfelder Farben
                    if(i===0) col=COLORS.red; if(i===10) col=COLORS.blue; if(i===20) col=COLORS.green; if(i===30) col=COLORS.yellow;
                    
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.3,0.2,2.3), new THREE.MeshStandardMaterial({color:col}));
                    m.position.copy(this.vec(i)); m.position.y=0.1; m.receiveShadow=true; this.s.add(m);
                    
                    if(this.traps.includes(i)) {
                        const q=new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.4), new THREE.MeshBasicMaterial({color:0xff00ff}));
                        q.position.copy(m.position); q.position.y=0.6; this.s.add(q);
                    }
                }
                
                // Bases
                ['red','blue','green','yellow'].forEach(c => {
                    let x=15, z=15; if(c==='blue') z=-15; if(c==='green'){x=-15;z=-15;} if(c==='yellow') x=-15;
                    const b = new THREE.Mesh(new THREE.CylinderGeometry(5,5,0.2,32), new THREE.MeshStandardMaterial({color:COLORS[c]}));
                    b.position.set(x,0.1,z); this.s.add(b);
                });

                // VISUALISIERUNG SAFE ZONES (Mitte)
                for(let step=1; step<=4; step++) {
                    this.addSafe('red', step, 0); 
                    this.addSafe('blue', step, 1);
                    this.addSafe('green', step, 2);
                    this.addSafe('yellow', step, 3);
                }
            }

            addSafe(c, step, rot) {
                // Von Arm-Eingang zur Mitte (0,0)
                // Arm Eingang ist quasi Abstand 5*Scale. Mitte ist 0.
                // Schritte 1-4.
                const dist = (5-step) * this.s;
                const v = new THREE.Vector3(0, 0, dist);
                // Rotieren
                const ang = -rot * Math.PI/2;
                const rx = v.x*Math.cos(ang) - v.z*Math.sin(ang);
                const rz = v.x*Math.sin(ang) + v.z*Math.cos(ang);
                
                const tile = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.2, 2.3), new THREE.MeshStandardMaterial({color:COLORS[c]}));
                tile.position.set(rx, 0.1, rz);
                this.s.add(tile);
            }

            vec(i) {
                const a=Math.floor(i/10), l=i%10; let x=0,z=0;
                if(l<5){x=1*this.s; z=(5-l)*this.s;} else {x=(l-3)*this.s; z=1*this.s;}
                const ang = -a*Math.PI/2;
                return new THREE.Vector3(x*Math.cos(ang)-z*Math.sin(ang), 0.1, x*Math.sin(ang)+z*Math.cos(ang));
            }
            abs(i,c){ let o=0; if(c==='blue')o=10; if(c==='green')o=20; if(c==='yellow')o=30; return (i+o)%40; }
            pos(i,c,idx) {
                if(i===-1) {
                    let x=15, z=15; if(c==='blue') z=-15; if(c==='green') {x=-15; z=-15;} if(c==='yellow') x=-15;
                    x += (idx%2===0?-1.5:1.5); z += (idx<2?-1.5:1.5);
                    return new THREE.Vector3(x,0,z);
                }
                if(i>=40) {
                     const st = i-40+1; const v = new THREE.Vector3(0,0,(5-st)*this.s);
                     let r=0; if(c==='blue')r=1; if(c==='green')r=2; if(c==='yellow')r=3;
                     const ang = -r*Math.PI/2;
                     return new THREE.Vector3(v.x*Math.cos(ang)-v.z*Math.sin(ang), 0, v.x*Math.sin(ang)+v.z*Math.cos(ang));
                }
                const v = this.vec(this.abs(i,c)); v.y=0; return v;
            }
            isTrap(a){return this.traps.includes(a);}
        }

        class Dice {
            constructor(s) {
                const g = new THREE.BoxGeometry(3,3,3); const m=[];
                for(let i=1;i<=6;i++){
                    const c=document.createElement('canvas');c.width=64;c.height=64;
                    const x=c.getContext('2d');x.fillStyle='#eee';x.fillRect(0,0,64,64);
                    x.fillStyle='red';x.font='40px Arial';x.textAlign='center';x.textBaseline='middle';x.fillText(i,32,32);
                    x.lineWidth=4;x.strokeRect(0,0,64,64);
                    m.push(new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(c)}));
                }
                this.m=new THREE.Mesh(g,m); this.m.position.set(0,5,0); s.add(this.m);
            }
            anim(v, cb) {
                let t=0; const i=setInterval(()=>{
                    this.m.rotation.x+=0.5; this.m.rotation.y+=0.5; t+=50;
                    if(t>800){clearInterval(i); this.m.rotation.set(0,0,0);
                    if(v===1)this.m.rotation.y=Math.PI/2; if(v===2)this.m.rotation.y=-Math.PI/2;
                    if(v===4)this.m.rotation.x=Math.PI; if(v===5)this.m.rotation.x=-Math.PI/2; if(v===6)this.m.rotation.x=Math.PI/2;
                    cb();}
                },50);
            }
        }
    </script>
</body>
</html>


