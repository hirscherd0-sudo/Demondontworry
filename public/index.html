<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graveyard Ludo 3D (Clear View)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #1a1a1a; color: #e0e0e0; }
        h1, h2 { font-family: 'Creepster', cursive; letter-spacing: 2px; color: #ff3333; text-shadow: 0 0 5px #000; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        
        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 20, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; pointer-events: auto;
        }

        .hidden { display: none !important; }

        /* Buttons & Inputs */
        button {
            background: #4a0000; border: 2px solid #880000; padding: 15px 30px; margin: 10px; 
            color: #ffffff; font-size: 1.2rem; cursor: pointer; border-radius: 4px;
            font-family: 'Creepster', cursive; transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:hover { background: #660000; transform: scale(1.05); }
        button:disabled { background: #333; border-color: #555; color: #888; cursor: not-allowed; transform: none; }
        input { padding: 10px; background: #333; border: 1px solid #666; color: white; font-size: 1rem; width: 200px; }

        /* HUD */
        #game-hud { display: none; padding: 20px; }
        .info-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(30, 30, 30, 0.9); padding: 20px; border: 1px solid #555;
            border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #turn-indicator { font-size: 1.2rem; margin-top: 5px; }
        
        #dice-btn {
            position: absolute; bottom: 50px; right: 50px;
            width: 100px; height: 100px; border-radius: 50%;
            font-size: 2.5rem; background: #220000; border: 3px solid #ff0000;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; pointer-events: auto;
        }
        #dice-btn:disabled { opacity: 0.5; cursor: default; border-color: #555; background: #333; box-shadow: none; }

        /* Quiz Modal */
        #quiz-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        .quiz-content {
            background: #2a2a2a; padding: 30px; border: 2px solid #ff3333; max-width: 600px; text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); border-radius: 10px;
        }
        .quiz-option {
            display: block; width: 100%; margin: 10px 0; padding: 12px;
            background: #444; border: 1px solid #666; color: white; text-align: left;
            cursor: pointer; transition: 0.2s; font-family: 'Roboto', sans-serif;
        }
        .quiz-option:hover { background: #666; border-color: #999; }

        /* Lobby List */
        #lobby-list { margin: 20px; width: 300px; text-align: left; background: #222; padding: 10px; border-radius: 5px; }
        .lobby-item { padding: 10px; border-bottom: 1px solid #444; display: flex; justify-content: space-between; }
        .waiting { color: #888; font-style: italic; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- Login / Start Screen -->
        <div id="login-screen" class="screen interactive">
            <h1>Graveyard Ludo</h1>
            <p>Tritt ein, wenn du dich traust...</p>
            <div style="margin-top:20px;">
                <input type="text" id="room-id" placeholder="Raum Name (z.B. Friedhof1)" value="Friedhof1">
                <button onclick="connectToLobby()">Betreten</button>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen interactive hidden">
            <h1>Die Lobby</h1>
            <div id="lobby-status">Warte auf Spieler...</div>
            <div id="lobby-list"></div>
            <p style="font-size:0.9rem; color:#aaa;">Freie PlÃ¤tze werden beim Start mit Horror-Bots gefÃ¼llt.</p>
            <button id="start-btn" onclick="requestStart()" disabled>Spiel Starten (Nur Host)</button>
        </div>

        <!-- In-Game HUD -->
        <div id="game-hud" class="interactive hidden">
            <div class="info-panel">
                <div id="status-text" style="color: #ff5555; font-weight: bold;">Spiel beginnt...</div>
                <div id="turn-indicator">Am Zug: <span id="current-player-name">---</span></div>
                <div id="dice-result" style="margin-top:10px; font-size:1.1em;">WÃ¼rfel: -</div>
            </div>
            <button id="dice-btn" onclick="game.rollDice()" disabled>ðŸŽ²</button>
        </div>

        <!-- Quiz Modal -->
        <div id="quiz-modal" class="interactive">
            <div class="quiz-content">
                <h2 style="margin-top:0">ðŸ‘» Geisterfrage! ðŸ‘»</h2>
                <p id="quiz-question" style="font-size:1.2em; margin-bottom:20px;">Frage text...</p>
                <div id="quiz-options"></div>
            </div>
        </div>
    </div>
    
    <script>
        // --- HORROR QUIZ DATEN ---
        const QUESTIONS = [
            { q: "Wie heiÃŸt der Killer in 'Halloween'?", a: ["Michael Myers", "Jason Voorhees", "Freddy Krueger", "Leatherface"], c: 0 },
            { q: "In welchem Film darfst du nicht einschlafen?", a: ["Scream", "A Nightmare on Elm Street", "Saw", "The Ring"], c: 1 },
            { q: "Welches GeisterjÃ¤ger-Spiel erfordert ein EMF-GerÃ¤t?", a: ["Ghostbusters", "Phasmophobia", "Luigi's Mansion", "Dead by Daylight"], c: 1 },
            { q: "Was passiert in 'The Ring' nach 7 Tagen?", a: ["Man stirbt", "Man gewinnt im Lotto", "Man wird zum Zombie", "Das Telefon klingelt"], c: 0 },
            { q: "Wie heiÃŸt der Clown in 'Es'?", a: ["Joker", "Pennywise", "Krusty", "Pogo"], c: 1 },
            { q: "Welches Item schÃ¼tzt in Phasmophobia vor einer Jagd?", a: ["Salz", "Kruzifix", "Taschenlampe", "EMF Reader"], c: 1 },
            { q: "Wer ist die Puppe in 'The Conjuring'?", a: ["Chucky", "Annabelle", "Billy", "Tiffany"], c: 1 },
            { q: "Welche Farbe hat Blut normalerweise in alten Filmen (Zensur)?", a: ["GrÃ¼n", "Schwarz", "Lila", "Blau"], c: 1 },
            { q: "Was ist Jason Voorhees' Waffe?", a: ["KettensÃ¤ge", "Machete", "Axt", "Messer"], c: 1 },
            { q: "In welchem Film sind VÃ¶gel die Gefahr?", a: ["The Birds", "Jaws", "Cujo", "Alien"], c: 0 },
            { q: "Wie viele Spieler kÃ¶nnen Phasmophobia max. spielen?", a: ["2", "3", "4", "5"], c: 2 },
            { q: "Was sagt der Geist in 'The Sixth Sense'?", a: ["Ich sehe tote Menschen", "Buh!", "Lauf weg", "Hilf mir"], c: 0 },
            { q: "Wie tÃ¶tet man einen Vampir klassischerweise?", a: ["Silberkugel", "Holzpfahl ins Herz", "Wasser", "Feuer"], c: 1 },
            { q: "Welcher Film spielt in einem Hotel?", a: ["The Shining", "Alien", "Poltergeist", "Saw"], c: 0 },
            { q: "Was ist ein 'Poltergeist'?", a: ["Ein lauter Geist", "Ein freundlicher Geist", "Ein DÃ¤mon", "Ein Zombie"], c: 0 },
            { q: "Wie heiÃŸt das MÃ¤dchen in 'Der Exorzist'?", a: ["Regan", "Carrie", "Samara", "Lucy"], c: 0 },
            { q: "Welches Tier ist Cujo?", a: ["Katze", "Hund", "Fledermaus", "Ratte"], c: 1 },
            { q: "Wovor hat Indiana Jones Angst (kein Horror, aber gruselig)?", a: ["Schlangen", "Spinnen", "HÃ¶he", "Geister"], c: 0 },
            { q: "Was ist ein Revenant in Phasmophobia?", a: ["Ein sehr schneller Geist", "Ein schÃ¼chterner Geist", "Ein lauter Geist", "Ein Schatten"], c: 0 },
            { q: "Wie viele 'Scream' Teile gibt es (Stand 2023)?", a: ["3", "4", "5", "6"], c: 3 }
        ];

        // --- KONFIGURATION ---
        const COLORS = {
            red: 0xcc0000,    
            blue: 0x0044cc,   
            green: 0x00cc00,  
            yellow: 0xffcc00, 
            stone: 0x888888,  // Helleres Grau fÃ¼r bessere Sichtbarkeit
            special: 0x9900ff 
        };

        const socket = io();
        let myData = { color: null, isHost: false };
        let players = [];
        let trapFields = []; 

        // --- LOBBY LOGIK ---
        function connectToLobby() {
            const roomId = document.getElementById('room-id').value;
            if(!roomId) return alert("Gib einen Namen fÃ¼r die Gruft ein!");
            socket.emit('joinGame', roomId);
        }

        function requestStart() {
            const roomId = document.getElementById('room-id').value;
            socket.emit('requestStartGame', roomId);
        }

        socket.on('joinedLobby', (data) => {
            myData = data;
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        socket.on('errorMsg', (msg) => alert(msg));

        socket.on('lobbyUpdate', (data) => {
            players = data.players;
            const list = document.getElementById('lobby-list');
            list.innerHTML = '';
            
            for(let i=0; i<4; i++) {
                const p = players[i];
                const div = document.createElement('div');
                div.className = 'lobby-item';
                if(p) {
                    div.innerHTML = `<span style="color:${p.color}; font-weight:bold;">${p.name || 'Spieler'}</span> ${data.hostId === p.id ? 'ðŸ‘‘' : ''}`;
                } else {
                    div.innerHTML = `<span class="waiting">Offen (wird Bot)</span>`;
                }
                list.appendChild(div);
            }

            const btn = document.getElementById('start-btn');
            if(data.isHost) {
                btn.disabled = false;
                btn.innerText = "Spiel Starten";
            } else {
                btn.disabled = true;
                btn.innerText = "Warte auf Host...";
            }
        });

        socket.on('gameStarted', (data) => {
            players = data.players;
            trapFields = data.trapFields; 
            
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-hud').classList.remove('hidden');
            
            startGame3D(data);
        });

        // --- 3D & GAME LOGIC ---

        class LudoBoard {
            constructor(scene) {
                this.scene = scene;
                this.createEnvironment();
                this.createBoardVisuals();
            }

            createEnvironment() {
                // Boden (Heller, damit man Kontrast sieht)
                const plane = new THREE.Mesh(
                    new THREE.BoxGeometry(60, 1, 60),
                    new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
                );
                plane.position.y = -0.5;
                plane.receiveShadow = true;
                this.scene.add(plane);

                // KEIN NEBEL MEHR FÃœR KLARE SICHT

                // Grabsteine (Deko)
                const stoneGeo = new THREE.BoxGeometry(1.5, 2.5, 0.5);
                const stoneMat = new THREE.MeshStandardMaterial({ color: 0x666666 }); // Helleres Grau
                
                for(let i=0; i<20; i++) {
                    const mesh = new THREE.Mesh(stoneGeo, stoneMat);
                    const angle = Math.random() * Math.PI * 2;
                    const r = 16 + Math.random() * 10;
                    mesh.position.set(Math.cos(angle)*r, 1, Math.sin(angle)*r);
                    mesh.rotation.y = Math.random() * 0.5;
                    mesh.rotation.z = (Math.random() - 0.5) * 0.2;
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                }
            }

            createBoardVisuals() {
                // Pfad visuell darstellen
                for(let i=0; i<40; i++) {
                    const pos = this.getPositionForIndex(i, 'red'); 
                    const isTrap = trapFields.includes(i);
                    const isSafe = [0,10,20,30].includes(i); 
                    
                    let color = COLORS.stone;
                    if(isTrap) color = COLORS.special;
                    if(isSafe) color = 0xaaaaaa; // Noch heller fÃ¼r Startfelder

                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.2, 1.2),
                        new THREE.MeshStandardMaterial({ 
                            color: color,
                            roughness: 0.5
                        })
                    );
                    tile.position.copy(pos);
                    tile.position.y = 0.1;
                    tile.receiveShadow = true;
                    this.scene.add(tile);
                    
                    if(isTrap) {
                        // Fragezeichen schwebend
                        const qGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                        const qMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                        const q = new THREE.Mesh(qGeo, qMat);
                        q.position.set(pos.x, 1.5, pos.z);
                        
                        // Animation fÃ¼r Fragezeichen
                        const animateQ = () => {
                            q.rotation.y += 0.02;
                            q.rotation.x += 0.01;
                            requestAnimationFrame(animateQ);
                        };
                        animateQ();
                        
                        this.scene.add(q);
                    }
                }

                // HÃ¤user visuell
                this.createHomeBase(10, 10, 'red');
                this.createHomeBase(-10, 10, 'blue');
                this.createHomeBase(-10, -10, 'green');
                this.createHomeBase(10, -10, 'yellow');
            }

            createHomeBase(x, z, color) {
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.5, 4, 0.2, 32),
                    new THREE.MeshStandardMaterial({ color: COLORS[color], roughness: 0.5 })
                );
                base.position.set(x, 0.1, z);
                base.receiveShadow = true;
                this.scene.add(base);
            }

            // Mathe fÃ¼r Kreispfad
            getPositionForIndex(index, playerColor) {
                const r = 8; 
                let offset = 0;
                if(playerColor === 'blue') offset = 10;
                if(playerColor === 'green') offset = 20;
                if(playerColor === 'yellow') offset = 30;

                let effectiveIndex = (index + offset) % 40;
                
                // Zielfelder
                if(index >= 40) {
                    const step = index - 40 + 1;
                    if(playerColor === 'red') return new THREE.Vector3(step*1.5, 0.2, 8);
                    if(playerColor === 'blue') return new THREE.Vector3(-8, 0.2, step*1.5);
                    if(playerColor === 'green') return new THREE.Vector3(-step*1.5, 0.2, -8);
                    if(playerColor === 'yellow') return new THREE.Vector3(8, 0.2, -step*1.5);
                    return new THREE.Vector3(0,1,0);
                }

                // Hauptpfad
                const angle = (effectiveIndex / 40) * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                return new THREE.Vector3(x, 0.2, z);
            }

            getHomePosition(playerColor, pieceIndex) {
                let bx=0, bz=0;
                if(playerColor === 'red') { bx=10; bz=10; }
                if(playerColor === 'blue') { bx=-10; bz=10; }
                if(playerColor === 'green') { bx=-10; bz=-10; }
                if(playerColor === 'yellow') { bx=10; bz=-10; }
                
                const offsetX = (pieceIndex % 2 === 0 ? -1.2 : 1.2);
                const offsetZ = (pieceIndex < 2 ? -1.2 : 1.2);
                return new THREE.Vector3(bx + offsetX, 0.5, bz + offsetZ);
            }
        }

        class HorrorPiece {
            constructor(color, index, scene, board) {
                this.color = color;
                this.index = index;
                this.positionIndex = -1; 
                this.board = board;
                this.meshGroup = new THREE.Group();
                this.scene = scene;

                this.createPuppetMesh(color);
                
                this.meshGroup.userData = { piece: this };
                scene.add(this.meshGroup);
                this.updatePositionVisuals(true);
            }

            createPuppetMesh(colorName) {
                const col = COLORS[colorName];

                // Kleid (Kegel)
                const dressGeo = new THREE.ConeGeometry(0.6, 1.5, 16);
                const dressMat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.5 });
                const dress = new THREE.Mesh(dressGeo, dressMat);
                dress.position.y = 0.75;
                dress.castShadow = true;
                this.meshGroup.add(dress);

                // Kopf (Kugel)
                const headGeo = new THREE.SphereGeometry(0.4, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee }); // Helle Haut
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.7;
                head.castShadow = true;
                this.meshGroup.add(head);

                // ZÃ¶pfe
                const hairMat = new THREE.MeshStandardMaterial({ color: 0xffdd88 });
                const pigtailLeft = new THREE.Mesh(new THREE.SphereGeometry(0.25), hairMat);
                pigtailLeft.position.set(-0.35, 1.8, 0);
                const pigtailRight = new THREE.Mesh(new THREE.SphereGeometry(0.25), hairMat);
                pigtailRight.position.set(0.35, 1.8, 0);
                this.meshGroup.add(pigtailLeft);
                this.meshGroup.add(pigtailRight);

                // Augen
                const eyeGeo = new THREE.SphereGeometry(0.06);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
                eyeL.position.set(-0.15, 1.75, 0.35);
                const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
                eyeR.position.set(0.15, 1.75, 0.35);
                this.meshGroup.add(eyeL);
                this.meshGroup.add(eyeR);
            }

            updatePositionVisuals(instant = false) {
                let targetPos;
                if(this.positionIndex === -1) {
                    targetPos = this.board.getHomePosition(this.color, this.index);
                } else {
                    targetPos = this.board.getPositionForIndex(this.positionIndex, this.color);
                }

                if(instant) {
                    this.meshGroup.position.copy(targetPos);
                } else {
                    const start = this.meshGroup.position.clone();
                    let alpha = 0;
                    const animate = () => {
                        alpha += 0.05;
                        if(alpha > 1) alpha = 1;
                        this.meshGroup.position.lerpVectors(start, targetPos, alpha);
                        this.meshGroup.position.y = targetPos.y + Math.sin(alpha * Math.PI) * 2;
                        if(alpha < 1) requestAnimationFrame(animate);
                        else this.meshGroup.position.y = targetPos.y;
                    };
                    animate();
                }
            }
        }

        class Game {
            constructor(serverData) {
                this.players = serverData.players;
                this.roomId = document.getElementById('room-id').value;
                this.myColor = myData.color;
                this.amIHost = myData.isHost;
                
                this.turnColor = 'red';
                this.rolledValue = null;
                this.hasRolled = false;
                this.isQuizActive = false;

                this.initThree();
                this.board = new LudoBoard(this.scene);
                this.pieces = [];
                this.initPieces();
                
                this.raycaster = new THREE.Raycaster();
                window.addEventListener('click', (e) => this.onMouseClick(e));
                
                this.setupSocketListeners();
                this.animate();
                this.updateUI();

                if(this.amIHost && this.players[0].isBot) {
                    setTimeout(() => this.checkBotTurn(), 2000);
                }
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x333333); // Dunkelgrauer Hintergrund, kein Schwarz

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 30, 25); // Etwas hÃ¶her fÃ¼r bessere Ãœbersicht
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // **NEUE BELEUCHTUNG FÃœR KLARE SICHT**
                // 1. Ambient Light - sorgt fÃ¼r Grundhelligkeit
                const ambient = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambient);

                // 2. Directional Light - simuliert starke Lichtquelle (Mond/Sonne)
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(20, 40, 20);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);

                // 3. Optional: Ein Pointlight fÃ¼r etwas AtmosphÃ¤re ohne Dunkelheit
                const accentLight = new THREE.PointLight(0xffaa00, 0.3);
                accentLight.position.set(0, 10, 0);
                this.scene.add(accentLight);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            initPieces() {
                ['red', 'blue', 'green', 'yellow'].forEach(c => {
                    for(let i=0; i<4; i++) {
                        this.pieces.push(new HorrorPiece(c, i, this.scene, this.board));
                    }
                });
            }

            setupSocketListeners() {
                socket.on('diceRolled', (data) => {
                    if(data.playerId !== socket.id) {
                        this.rolledValue = data.value;
                        this.hasRolled = true;
                        document.getElementById('dice-result').innerText = `WÃ¼rfel: ${data.value}`;
                    }
                });

                socket.on('pieceMoved', (data) => {
                    const pieces = this.pieces.filter(p => p.color === this.turnColor);
                    const piece = pieces[data.pieceId];
                    
                    if(piece) {
                        piece.positionIndex = data.newPosition;
                        piece.updatePositionVisuals();
                        this.checkCollisions(piece);
                    }
                });

                socket.on('turnChanged', (data) => {
                    this.turnColor = data.activeColor;
                    this.hasRolled = false;
                    this.rolledValue = null;
                    this.updateUI();
                    
                    if(this.amIHost && data.isBot) {
                        setTimeout(() => this.botTurn(), 1500);
                    }
                });
            }

            checkBotTurn() {
                const currentPlayer = this.players.find(p => p.color === this.turnColor);
                if(currentPlayer && currentPlayer.isBot && this.amIHost) {
                    this.botTurn();
                }
            }

            botTurn() {
                const val = Math.floor(Math.random() * 6) + 1;
                socket.emit('rollDice', { roomId: this.roomId, diceValue: val });
                this.rolledValue = val;
                this.hasRolled = true;

                setTimeout(() => {
                    const myPieces = this.pieces.filter(p => p.color === this.turnColor);
                    let moved = false;
                    
                    for(let p of myPieces) {
                        if(p.positionIndex === -1 && val === 6) {
                            this.executeMove(p, 0); moved = true; break;
                        }
                        else if(p.positionIndex !== -1 && p.positionIndex + val <= 43) {
                            this.executeMove(p, p.positionIndex + val); moved = true; break;
                        }
                    }

                    if(!moved) {
                        socket.emit('endTurn', { roomId: this.roomId });
                    } else if(val === 6) {
                        this.hasRolled = false;
                        setTimeout(() => this.botTurn(), 1000);
                    }
                }, 1000);
            }

            rollDice() {
                if(this.turnColor !== this.myColor) return;
                
                const val = Math.floor(Math.random() * 6) + 1;
                this.rolledValue = val;
                this.hasRolled = true;
                
                document.getElementById('dice-btn').disabled = true;
                document.getElementById('dice-result').innerText = `WÃ¼rfel: ${val}`;
                socket.emit('rollDice', { roomId: this.roomId, diceValue: val });

                const canMove = this.pieces.filter(p => p.color === this.myColor).some(p => 
                    (p.positionIndex === -1 && val === 6) || 
                    (p.positionIndex !== -1 && p.positionIndex + val <= 43)
                );

                if(!canMove) {
                    setTimeout(() => socket.emit('endTurn', { roomId: this.roomId }), 1500);
                }
            }

            onMouseClick(event) {
                if(this.isQuizActive) return;
                if(!this.hasRolled) return;
                if(this.turnColor !== this.myColor) return;

                const mouse = new THREE.Vector2(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                this.raycaster.setFromCamera(mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                for(let hit of intersects) {
                    let obj = hit.object;
                    while(obj && !obj.userData.piece) obj = obj.parent;

                    if(obj && obj.userData.piece) {
                        const p = obj.userData.piece;
                        if(p.color === this.turnColor) {
                            this.tryMove(p);
                            return;
                        }
                    }
                }
            }

            tryMove(piece) {
                let newPos = -1;
                if(piece.positionIndex === -1) {
                    if(this.rolledValue === 6) newPos = 0; else return;
                } else {
                    newPos = piece.positionIndex + this.rolledValue;
                    if(newPos > 43) return; 
                }

                const r = this.getAbsoluteIndex(newPos, this.myColor);
                this.executeMove(piece, newPos);

                if(trapFields.includes(r) && newPos < 40) {
                    this.triggerQuiz(piece);
                } else {
                    this.finishTurnLogic();
                }
            }

            getAbsoluteIndex(relIndex, color) {
                let offset = 0;
                if(color === 'blue') offset = 10;
                if(color === 'green') offset = 20;
                if(color === 'yellow') offset = 30;
                return (relIndex + offset) % 40;
            }

            executeMove(piece, newPos) {
                piece.positionIndex = newPos;
                piece.updatePositionVisuals();
                this.checkCollisions(piece);

                socket.emit('movePiece', { 
                    roomId: this.roomId, 
                    pieceId: piece.index, 
                    newPosition: newPos,
                    isFinished: newPos >= 40
                });
            }

            checkCollisions(movedPiece) {
                if(movedPiece.positionIndex === -1 || movedPiece.positionIndex >= 40) return;
                const absPos = this.getAbsoluteIndex(movedPiece.positionIndex, movedPiece.color);

                this.pieces.forEach(p => {
                    if(p === movedPiece) return;
                    if(p.positionIndex === -1 || p.positionIndex >= 40) return;
                    
                    const pAbs = this.getAbsoluteIndex(p.positionIndex, p.color);
                    if(absPos === pAbs) {
                        p.positionIndex = -1;
                        p.updatePositionVisuals();
                    }
                });
            }

            triggerQuiz(piece) {
                this.isQuizActive = true;
                const modal = document.getElementById('quiz-modal');
                const qText = document.getElementById('quiz-question');
                const qOpt = document.getElementById('quiz-options');
                
                const qIdx = Math.floor(Math.random() * QUESTIONS.length);
                const qData = QUESTIONS[qIdx];

                qText.innerText = qData.q;
                qOpt.innerHTML = '';

                qData.a.forEach((ans, i) => {
                    const btn = document.createElement('button');
                    btn.className = 'quiz-option';
                    btn.innerText = ans;
                    btn.onclick = () => this.handleQuizAnswer(i === qData.c, piece, modal);
                    qOpt.appendChild(btn);
                });

                modal.style.display = 'flex';
            }

            handleQuizAnswer(isCorrect, piece, modal) {
                modal.style.display = 'none';
                this.isQuizActive = false;

                if(isCorrect) {
                    alert("Richtig! Du darfst nochmal wÃ¼rfeln!");
                    this.hasRolled = false;
                    document.getElementById('dice-btn').disabled = false;
                } else {
                    alert("FALSCH! ZurÃ¼ck ins Haus!");
                    piece.positionIndex = -1;
                    piece.updatePositionVisuals();
                    socket.emit('movePiece', { 
                        roomId: this.roomId, 
                        pieceId: piece.index, 
                        newPosition: -1
                    });
                    this.finishTurnLogic(false);
                }
            }

            finishTurnLogic(allowExtra = true) {
                if(allowExtra && this.rolledValue === 6) {
                    this.hasRolled = false;
                    document.getElementById('dice-btn').disabled = false;
                    document.getElementById('status-text').innerText = "Eine 6! WÃ¼rfle erneut.";
                } else {
                    socket.emit('endTurn', { roomId: this.roomId });
                }
            }

            updateUI() {
                const pInfo = document.getElementById('current-player-name');
                const diceBtn = document.getElementById('dice-btn');
                const status = document.getElementById('status-text');
                
                const pObj = this.players.find(p => p.color === this.turnColor);
                const name = pObj ? pObj.name : this.turnColor;
                
                pInfo.innerText = name + (pObj && pObj.isBot ? " (Bot)" : "");
                pInfo.style.color = COLORS[this.turnColor] === 0xffcc00 ? '#ffcc00' : this.turnColor; // Gelb korrigieren

                if(this.turnColor === this.myColor) {
                    status.innerText = "DU bist dran!";
                    if(!this.hasRolled) diceBtn.disabled = false;
                } else {
                    status.innerText = "Warte auf Zug...";
                    diceBtn.disabled = true;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        let game;
        function startGame3D(serverData) {
            game = new Game(serverData);
        }

    </script>
</body>
</html>


